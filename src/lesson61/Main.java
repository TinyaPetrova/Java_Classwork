package lesson61;

public class Main {

  // String как коллекция символов
  // - неизменяемая (не можем менять содержимое)
  // - упорядоченная (есть индексы)
  // - получение элемента по индексу:
  // - O(1) - адрес начала + индекс
  // array (int[]) - постоянный размер, упорядоченная
  // - получение или изменение (обращение к) элемента по индексу
  // O(1) - адрес начала + индекс

  // List: ArrayList, LinkedList
  // Set: HashSet
  // Map: HashMap

  // List:
  // ArrayList - упорядоченная
  // - добавление элемента
  //    - в конец - O(1), иногда O(n)
  //    - в начало и середину - O(n / 2) = O(0.5 * n) = O(n)
  //    - по итератору - O(n)
  // - обращение по индексу
  //   O(1) - как в array
  // - удаление элемента
  //   - с конца - О(1)
  //   - из начала и середины - О(n)
  // LinkedList
  // - добавление элемента
  //   - в начало - O(1)
  //   - по итератору - O(1)
  //   - в середину - O(n)
  //   O(n / 2) + 1 <= 10n / 2 + 1 <= 5    * n + 1 <= 5 * n      + n <= 6 * n = O(n)
  //   O(n / 2) + 1 <= c * n / 2 + 1 <= (c / 2) * n + 1 <= (c / 2) * n <= (c / 2 + 1) * n
  //   - в конец - 0(1) (теоретически O(n))
  // обращение по индексу
  //   - O(n)
  //   - по итератору - O(1)
  // удаление элемента
  //   - из начала - O(1)
  //   - по итератору - O(1)
  //   - из середины - O(n) для поиска
  //   - из конца - O(1) (теоретически O(n) для поиска)
  // Set:
  // HashSet - требуется hashCode - неупорядоченная, без повторения элементов
  //   проверяем hash, при одинаковом - сравниваем
  // - добавление
  // - поиск
  // - удаление
  //    всё это одинаково для операций выше:
  //    - подсчёт хэша - 0(1), но мб долгим. Для строк O(length)
  //    - выбор ведёрка (bucket) с таким же хэшем
  //    - сравнение с остальным содержимым - O(bucket_size)
  //    в самом плохом случае (для плохих хэш-функций, когда много значений
  //    попадает в одно ведёрко и имеют один хэш (много коллизий)) превращается в O(n)
  //    и ведёт себя как ArrayList с линейным поиском
  // TreeSet - требуется Comparable или Comparator - упорядоченная
  //   всегда хранит элементы отсортированными по возрастанию
  //   новое место или существующий элемент всегда ищутся бинарным поиском - 0(log n)
  //   |----------| - n
  //        |-----| - размер меньше в 2 раза (Х раз, пока не дойдем до след. шага)
  //            |-| - размер 1
  //   сложность: сколько раз надо n разделить на 2, чтобы получить 1
  //      сколько раз надо 1 умножить на 2, чтобы получить n
  //      1 * 2 * 2 * 2 * 2... * 2 = n    - кол-во двоек
  //          2 * 2 * 2 * 2... * 2 = n    - кол-во двоек
  //                         2 ^ k = n    - k (степень двух)
  //      A ^ P = R - A в степени P равно R
  //      логарифм - это степень, в которую нужно возвести основание, чтобы получить аргумент
  //      логарифм по основанию A от аргумента R равен P
  //      2 ^ k = n
  //      логарифм - это степень, в которую нужно возвести основание, чтобы получить аргумент
  //      k        - это степень, в которую нужно возвести 2,         чтобы получить n
  //      логарифм по основанию 2 от n равен k
  //      k = log2(n)
  //      log_a(b) = log b / log a (где log - натуральный или десятичный)
  //      k = log2(n) = log n / log 2 = c * log n = O(log n)
  // - добавление
  // - поиск (проверка существования)
  // - удаление
  //   O(log n)
  // Map:
  // HashMap
  // - ключи как в HashSet
  // TreeMap
  // - ключи как в TreeSet (аналогия: гирлянда-водопад)
  public static void main(String[] args) {
    System.out.println("Hello");
  }
}
